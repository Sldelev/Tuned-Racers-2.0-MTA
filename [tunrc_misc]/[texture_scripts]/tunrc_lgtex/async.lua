local function a()local b=[[
    Copyright (c) 2011-2014 Bart van Strien

    This software is provided 'as-is', without any express or implied
    warranty. In no event will the authors be held liable for any damages
    arising from the use of this software.

    Permission is granted to anyone to use this software for any purpose,
    including commercial applications, and to alter it and redistribute it
    freely, subject to the following restrictions:

      1. The origin of this software must not be misrepresented; you must not
      claim that you wrote the original software. If you use this software
      in a product, an acknowledgment in the product documentation would be
      appreciated but is not required.

      2. Altered source versions must be plainly marked as such, and must not be
      misrepresented as being the original software.

      3. This notice may not be removed or altered from any source
      distribution.
    ]]local c={_VERSION="Slither 20140904",_DESCRIPTION="Slither is a pythonic class library for lua",_URL="http://bitbucket.org/bartbes/slither",_LICENSE=b}local function d(e)local f=_G;local g;for h in e:gmatch("[^%.]+")do f=g and f[g]or f;g=h end;return f,g end;local function i(g,j,f)local k={}for l,m in ipairs(j)do k[m]=true;for l,m in ipairs(m.__parents__)do k[m]=true end end;local n={__parents__={}}for o,m in pairs(k)do table.insert(n.__parents__,o)end;local c=setmetatable(n,{__index=function(self,p)if p=="__class__"then return n end;if p=="__name__"then return g end;if f[p]~=nil then return f[p]end;for o,m in ipairs(j)do if m[p]~=nil then return m[p]end end;if tostring(p):match("^__.+__$")then return end;if self.__getattr__ then return self:__getattr__(p)end end,__newindex=function(self,p,q)f[p]=q end,allocate=function(r)local s=getmetatable(n)local t={__index=s.__index}function t:__newindex(p,q)if self.__setattr__ then return self:__setattr__(p,q)else return rawset(self,p,q)end end;if n.__cmp__ then if not s.eq or not s.lt then function s.eq(u,j)return u.__cmp__(u,j)==0 end;function s.lt(u,j)return u.__cmp__(u,j)<0 end end;t.__eq=s.eq;t.__lt=s.lt end;for o,m in pairs{__call__="__call",__len__="__len",__add__="__add",__sub__="__sub",__mul__="__mul",__div__="__div",__mod__="__mod",__pow__="__pow",__neg__="__unm",__concat__="__concat",__str__="__tostring"}do if n[o]then t[m]=n[o]end end;return setmetatable(r or{},t)end,__call=function(self,...)local r=getmetatable(self).allocate()if r.__init__ then r:__init__(...)end;return r end})for o,m in ipairs(f.__attributes__ or{})do c=m(c)or c end;return c end;local function v(w,g,...)local x={...}for o=1,select("#",...)do if x[o]==nil then error("nil passed to class, check the parents")end end;local f=nil;if#x==1 and type(x[1])=="table"and not x[1].__class__ then f=x[1]x={}end;for o,m in ipairs(x)do if type(m)=="string"then local f,g=d(m)x[o]=f[g]end end;local y=function(f)local c=i(g,x,f)if w then local z,g=d(g)z[g]=c end;return c end;if f then return y(f)else return y end end;function c.private(g)return function(...)return v(false,g,...)end end;c=setmetatable(c,{__call=function(self,g)return function(...)return v(true,g,...)end end})function c.issubclass(c,k)if k.__class__ then k={k}end;for o,m in ipairs(k)do local A=true;if m~=c then A=false;for l,B in ipairs(c.__parents__)do if m==B then A=true;break end end end;if not A then return false end end;return true end;function c.isinstance(C,k)return type(C)=="table"and C.__class__ and c.issubclass(C.__class__,k)end;if common_class~=false then common={}function common.class(g,D,E)D.__init__=D.init;return i(g,{E},D)end;function common.instance(c,...)return c(...)end end;return c end;local c=a()c"_Async"{__init__=function(self)self.threads={}self.resting=50;self.maxtime=200;self.current=0;self.state="suspended"self.debug=false;self.priority={low={500,50},normal={200,200},high={50,500}}self:setPriority("normal")end,switch=function(self,F)self.state="running"if self.current+1<=#self.threads then self.current=self.current+1;self:execute(self.current)else self.current=0;if#self.threads<=0 then self.state="suspended"return end;setTimer(function()self:switch()end,self.resting,1)end end,execute=function(self,G)local H=self.threads[G]if H==nil or coroutine.status(H)=="dead"then table.remove(self.threads,G)self:switch()else coroutine.resume(H)self:switch()end end,add=function(self,y)local H=coroutine.create(y)table.insert(self.threads,H)end,setPriority=function(self,I,J)if type(I)=="string"then if self.priority[I]~=nil then self.resting=self.priority[I][1]self.maxtime=self.priority[I][2]end else self.resting=I;self.maxtime=J end end,setDebug=function(self,q)self.debug=q end,iterate=function(self,K,L,y,M)self:add(function()local u=getTickCount()local N=getTickCount()for o=K,L do y(o)if getTickCount()>N+self.maxtime then coroutine.yield()N=getTickCount()end end;if self.debug then print("[DEBUG]Async iterate: "..getTickCount()-u.."ms")end;if M then M()end end)self:switch()end,foreach=function(self,O,y,M)self:add(function()local u=getTickCount()local N=getTickCount()for P,m in ipairs(O)do y(m,P)if getTickCount()>N+self.maxtime then coroutine.yield()N=getTickCount()end end;if self.debug then print("[DEBUG]Async foreach: "..getTickCount()-u.."ms")end;if M then M()end end)self:switch()end}Async={instance=nil}local function Q()if Async.instance==nil then Async.instance=_Async()end;return Async.instance end;function Async:setDebug(...)Q():setDebug(...)end;function Async:setPriority(...)Q():setPriority(...)end;function Async:iterate(...)Q():iterate(...)end;function Async:foreach(...)Q():foreach(...)end